# ! [ feature ( prelude_import ) ] # [ prelude_import ] use std :: prelude :: v1 :: * ; # [ macro_use ] extern crate std ; use borsh :: { BorshDeserialize , BorshSerialize } ; use near_bindgen :: { env , metadata , near_bindgen } ; use std :: collections :: HashMap ; static ALLOC : wee_alloc :: WeeAlloc = wee_alloc :: WeeAlloc :: INIT ; const _ : ( ) = { # [ rustc_std_internal_symbol ] unsafe fn __rg_alloc ( arg0 : usize , arg1 : usize ) -> * mut u8 { :: core :: alloc :: GlobalAlloc :: alloc ( & ALLOC , :: core :: alloc :: Layout :: from_size_align_unchecked ( arg0 , arg1 ) ) as * mut u8 } # [ rustc_std_internal_symbol ] unsafe fn __rg_dealloc ( arg0 : * mut u8 , arg1 : usize , arg2 : usize ) -> ( ) { :: core :: alloc :: GlobalAlloc :: dealloc ( & ALLOC , arg0 as * mut u8 , :: core :: alloc :: Layout :: from_size_align_unchecked ( arg1 , arg2 ) ) } # [ rustc_std_internal_symbol ] unsafe fn __rg_realloc ( arg0 : * mut u8 , arg1 : usize , arg2 : usize , arg3 : usize ) -> * mut u8 { :: core :: alloc :: GlobalAlloc :: realloc ( & ALLOC , arg0 as * mut u8 , :: core :: alloc :: Layout :: from_size_align_unchecked ( arg1 , arg2 ) , arg3 ) as * mut u8 } # [ rustc_std_internal_symbol ] unsafe fn __rg_alloc_zeroed ( arg0 : usize , arg1 : usize ) -> * mut u8 { :: core :: alloc :: GlobalAlloc :: alloc_zeroed ( & ALLOC , :: core :: alloc :: Layout :: from_size_align_unchecked ( arg0 , arg1 ) ) as * mut u8 } } ; pub struct StatusMessage { records : HashMap < String , String > , } # [ automatically_derived ] # [ allow ( unused_qualifications ) ] impl :: core :: default :: Default for StatusMessage { # [ inline ] fn default ( ) -> StatusMessage { StatusMessage { records : :: core :: default :: Default :: default ( ) , } } } impl borsh :: de :: BorshDeserialize for StatusMessage where HashMap < String , String > : borsh :: BorshDeserialize { fn deserialize < R : std :: io :: Read > ( reader : & mut R ) -> std :: result :: Result < Self , std :: io :: Error > { Ok ( Self { records : borsh :: BorshDeserialize :: deserialize ( reader ) ? , } ) } } impl borsh :: ser :: BorshSerialize for StatusMessage where HashMap < String , String > : borsh :: ser :: BorshSerialize { fn serialize < W : std :: io :: Write > ( & self , writer : & mut W ) -> Result < ( ) , std :: io :: Error > { borsh :: BorshSerialize :: serialize ( & self . records , writer ) ? ; Ok ( ( ) ) } } # [ cfg ( target_arch = "wasm32" ) ] pub mod sys { extern "C" { pub fn read_register ( register_id : u64 , ptr : u64 ) ; pub fn register_len ( register_id : u64 ) -> u64 ; pub fn current_account_id ( register_id : u64 ) ; pub fn signer_account_id ( register_id : u64 ) ; pub fn signer_account_pk ( register_id : u64 ) ; pub fn predecessor_account_id ( register_id : u64 ) ; pub fn input ( register_id : u64 ) ; pub fn block_index ( ) -> u64 ; pub fn block_timestamp ( ) -> u64 ; pub fn storage_usage ( ) -> u64 ; pub fn account_balance ( balance_ptr : u64 ) ; pub fn account_locked_balance ( balance_ptr : u64 ) ; pub fn attached_deposit ( balance_ptr : u64 ) ; pub fn prepaid_gas ( ) -> u64 ; pub fn used_gas ( ) -> u64 ; pub fn random_seed ( register_id : u64 ) ; pub fn sha256 ( value_len : u64 , value_ptr : u64 , register_id : u64 ) ; pub fn keccak256 ( value_len : u64 , value_ptr : u64 , register_id : u64 ) ; pub fn keccak512 ( value_len : u64 , value_ptr : u64 , register_id : u64 ) ; pub fn value_return ( value_len : u64 , value_ptr : u64 ) ; pub fn panic ( ) ; pub fn panic_utf8 ( len : u64 , ptr : u64 ) ; pub fn log_utf8 ( len : u64 , ptr : u64 ) ; pub fn log_utf16 ( len : u64 , ptr : u64 ) ; pub fn promise_create ( account_id_len : u64 , account_id_ptr : u64 , method_name_len : u64 , method_name_ptr : u64 , arguments_len : u64 , arguments_ptr : u64 , amount_ptr : u64 , gas : u64 ) -> u64 ; pub fn promise_then ( promise_index : u64 , account_id_len : u64 , account_id_ptr : u64 , method_name_len : u64 , method_name_ptr : u64 , arguments_len : u64 , arguments_ptr : u64 , amount_ptr : u64 , gas : u64 ) -> u64 ; pub fn promise_and ( promise_idx_ptr : u64 , promise_idx_count : u64 ) -> u64 ; pub fn promise_batch_create ( account_id_len : u64 , account_id_ptr : u64 ) -> u64 ; pub fn promise_batch_then ( promise_index : u64 , account_id_len : u64 , account_id_ptr : u64 ) -> u64 ; pub fn promise_batch_action_create_account ( promise_index : u64 ) ; pub fn promise_batch_action_deploy_contract ( promise_index : u64 , code_len : u64 , code_ptr : u64 ) ; pub fn promise_batch_action_function_call ( promise_index : u64 , method_name_len : u64 , method_name_ptr : u64 , arguments_len : u64 , arguments_ptr : u64 , amount_ptr : u64 , gas : u64 ) ; pub fn promise_batch_action_transfer ( promise_index : u64 , amount_ptr : u64 ) ; pub fn promise_batch_action_stake ( promise_index : u64 , amount_ptr : u64 , public_key_len : u64 , public_key_ptr : u64 ) ; pub fn promise_batch_action_add_key_with_full_access ( promise_index : u64 , public_key_len : u64 , public_key_ptr : u64 , nonce : u64 ) ; pub fn promise_batch_action_add_key_with_function_call ( promise_index : u64 , public_key_len : u64 , public_key_ptr : u64 , nonce : u64 , allowance_ptr : u64 , receiver_id_len : u64 , receiver_id_ptr : u64 , method_names_len : u64 , method_names_ptr : u64 ) ; pub fn promise_batch_action_delete_key ( promise_index : u64 , public_key_len : u64 , public_key_ptr : u64 ) ; pub fn promise_batch_action_delete_account ( promise_index : u64 , beneficiary_id_len : u64 , beneficiary_id_ptr : u64 ) ; pub fn promise_results_count ( ) -> u64 ; pub fn promise_result ( result_idx : u64 , register_id : u64 ) -> u64 ; pub fn promise_return ( promise_id : u64 ) ; pub fn storage_write ( key_len : u64 , key_ptr : u64 , value_len : u64 , value_ptr : u64 , register_id : u64 ) -> u64 ; pub fn storage_read ( key_len : u64 , key_ptr : u64 , register_id : u64 ) -> u64 ; pub fn storage_remove ( key_len : u64 , key_ptr : u64 , register_id : u64 ) -> u64 ; pub fn storage_has_key ( key_len : u64 , key_ptr : u64 ) -> u64 ; } } # [ cfg ( target_arch = "wasm32" ) ] pub mod near_blockchain { use super :: sys ; use near_bindgen :: BlockchainInterface ; # [ doc = " Implementation of the blockchain interface that contracts actually use during the execution" ] # [ doc = " of the contract." ] pub struct NearBlockchain { } impl BlockchainInterface for NearBlockchain { unsafe fn read_register ( & self , register_id : u64 , ptr : u64 ) { sys :: read_register ( register_id , ptr ) } unsafe fn register_len ( & self , register_id : u64 ) -> u64 { sys :: register_len ( register_id ) } unsafe fn current_account_id ( & self , register_id : u64 ) { sys :: current_account_id ( register_id ) } unsafe fn signer_account_id ( & self , register_id : u64 ) { sys :: signer_account_id ( register_id ) } unsafe fn signer_account_pk ( & self , register_id : u64 ) { sys :: signer_account_pk ( register_id ) } unsafe fn predecessor_account_id ( & self , register_id : u64 ) { sys :: predecessor_account_id ( register_id ) } unsafe fn input ( & self , register_id : u64 ) { sys :: input ( register_id ) } unsafe fn block_index ( & self ) -> u64 { sys :: block_index ( ) } unsafe fn block_timestamp ( & self ) -> u64 { sys :: block_timestamp ( ) } unsafe fn storage_usage ( & self ) -> u64 { sys :: storage_usage ( ) } unsafe fn account_balance ( & self , balance_ptr : u64 ) { sys :: account_balance ( balance_ptr ) } unsafe fn account_locked_balance ( & self , balance_ptr : u64 ) { sys :: account_locked_balance ( balance_ptr ) } unsafe fn attached_deposit ( & self , balance_ptr : u64 ) { sys :: attached_deposit ( balance_ptr ) } unsafe fn prepaid_gas ( & self ) -> u64 { sys :: prepaid_gas ( ) } unsafe fn used_gas ( & self ) -> u64 { sys :: used_gas ( ) } unsafe fn random_seed ( & self , register_id : u64 ) { sys :: random_seed ( register_id ) } unsafe fn sha256 ( & self , value_len : u64 , value_ptr : u64 , register_id : u64 ) { sys :: sha256 ( value_len , value_ptr , register_id ) } unsafe fn keccak256 ( & self , value_len : u64 , value_ptr : u64 , register_id : u64 ) { sys :: keccak256 ( value_len , value_ptr , register_id ) } unsafe fn keccak512 ( & self , value_len : u64 , value_ptr : u64 , register_id : u64 ) { sys :: keccak512 ( value_len , value_ptr , register_id ) } unsafe fn value_return ( & self , value_len : u64 , value_ptr : u64 ) { sys :: value_return ( value_len , value_ptr ) } unsafe fn panic ( & self ) { sys :: panic ( ) } unsafe fn panic_utf8 ( & self , len : u64 , ptr : u64 ) { sys :: panic_utf8 ( len , ptr ) } unsafe fn log_utf8 ( & self , len : u64 , ptr : u64 ) { sys :: log_utf8 ( len , ptr ) } unsafe fn log_utf16 ( & self , len : u64 , ptr : u64 ) { sys :: log_utf16 ( len , ptr ) } unsafe fn promise_create ( & self , account_id_len : u64 , account_id_ptr : u64 , method_name_len : u64 , method_name_ptr : u64 , arguments_len : u64 , arguments_ptr : u64 , amount_ptr : u64 , gas : u64 ) -> u64 { sys :: promise_create ( account_id_len , account_id_ptr , method_name_len , method_name_ptr , arguments_len , arguments_ptr , amount_ptr , gas ) } unsafe fn promise_then ( & self , promise_index : u64 , account_id_len : u64 , account_id_ptr : u64 , method_name_len : u64 , method_name_ptr : u64 , arguments_len : u64 , arguments_ptr : u64 , amount_ptr : u64 , gas : u64 ) -> u64 { sys :: promise_then ( promise_index , account_id_len , account_id_ptr , method_name_len , method_name_ptr , arguments_len , arguments_ptr , amount_ptr , gas ) } unsafe fn promise_and ( & self , promise_idx_ptr : u64 , promise_idx_count : u64 ) -> u64 { sys :: promise_and ( promise_idx_ptr , promise_idx_count ) } unsafe fn promise_batch_create ( & self , account_id_len : u64 , account_id_ptr : u64 ) -> u64 { sys :: promise_batch_create ( account_id_len , account_id_ptr ) } unsafe fn promise_batch_then ( & self , promise_index : u64 , account_id_len : u64 , account_id_ptr : u64 ) -> u64 { sys :: promise_batch_then ( promise_index , account_id_len , account_id_ptr ) } unsafe fn promise_batch_action_create_account ( & self , promise_index : u64 ) { sys :: promise_batch_action_create_account ( promise_index ) } unsafe fn promise_batch_action_deploy_contract ( & self , promise_index : u64 , code_len : u64 , code_ptr : u64 ) { sys :: promise_batch_action_deploy_contract ( promise_index , code_len , code_ptr ) } unsafe fn promise_batch_action_function_call ( & self , promise_index : u64 , method_name_len : u64 , method_name_ptr : u64 , arguments_len : u64 , arguments_ptr : u64 , amount_ptr : u64 , gas : u64 ) { sys :: promise_batch_action_function_call ( promise_index , method_name_len , method_name_ptr , arguments_len , arguments_ptr , amount_ptr , gas ) } unsafe fn promise_batch_action_transfer ( & self , promise_index : u64 , amount_ptr : u64 ) { sys :: promise_batch_action_transfer ( promise_index , amount_ptr ) } unsafe fn promise_batch_action_stake ( & self , promise_index : u64 , amount_ptr : u64 , public_key_len : u64 , public_key_ptr : u64 ) { sys :: promise_batch_action_stake ( promise_index , amount_ptr , public_key_len , public_key_ptr ) } unsafe fn promise_batch_action_add_key_with_full_access ( & self , promise_index : u64 , public_key_len : u64 , public_key_ptr : u64 , nonce : u64 ) { sys :: promise_batch_action_add_key_with_full_access ( promise_index , public_key_len , public_key_ptr , nonce ) } unsafe fn promise_batch_action_add_key_with_function_call ( & self , promise_index : u64 , public_key_len : u64 , public_key_ptr : u64 , nonce : u64 , allowance_ptr : u64 , receiver_id_len : u64 , receiver_id_ptr : u64 , method_names_len : u64 , method_names_ptr : u64 ) { sys :: promise_batch_action_add_key_with_function_call ( promise_index , public_key_len , public_key_ptr , nonce , allowance_ptr , receiver_id_len , receiver_id_ptr , method_names_len , method_names_ptr ) } unsafe fn promise_batch_action_delete_key ( & self , promise_index : u64 , public_key_len : u64 , public_key_ptr : u64 ) { sys :: promise_batch_action_delete_key ( promise_index , public_key_len , public_key_ptr ) } unsafe fn promise_batch_action_delete_account ( & self , promise_index : u64 , beneficiary_id_len : u64 , beneficiary_id_ptr : u64 ) { sys :: promise_batch_action_delete_account ( promise_index , beneficiary_id_len , beneficiary_id_ptr ) } unsafe fn promise_results_count ( & self ) -> u64 { sys :: promise_results_count ( ) } unsafe fn promise_result ( & self , result_idx : u64 , register_id : u64 ) -> u64 { sys :: promise_result ( result_idx , register_id ) } unsafe fn promise_return ( & self , promise_id : u64 ) { sys :: promise_return ( promise_id ) } unsafe fn storage_write ( & self , key_len : u64 , key_ptr : u64 , value_len : u64 , value_ptr : u64 , register_id : u64 ) -> u64 { sys :: storage_write ( key_len , key_ptr , value_len , value_ptr , register_id ) } unsafe fn storage_read ( & self , key_len : u64 , key_ptr : u64 , register_id : u64 ) -> u64 { sys :: storage_read ( key_len , key_ptr , register_id ) } unsafe fn storage_remove ( & self , key_len : u64 , key_ptr : u64 , register_id : u64 ) -> u64 { sys :: storage_remove ( key_len , key_ptr , register_id ) } unsafe fn storage_has_key ( & self , key_len : u64 , key_ptr : u64 ) -> u64 { sys :: storage_has_key ( key_len , key_ptr ) } } } impl StatusMessage { pub fn set_status ( & mut self , message : String ) { let account_id = env :: signer_account_id ( ) ; self . records . insert ( account_id , message ) ; } pub fn get_status ( & self , account_id : String ) -> Option < String > { self . records . get ( & account_id ) . cloned ( ) } } # [ cfg ( target_arch = "wasm32" ) ] # [ no_mangle ] pub extern "C" fn set_status ( ) { near_bindgen :: env :: setup_panic_hook ( ) ; near_bindgen :: env :: set_blockchain_interface ( Box :: new ( near_blockchain :: NearBlockchain { } ) ) ; struct Input { message : String , } # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_DESERIALIZE_FOR_Input : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ allow ( unused_macros ) ] macro_rules ! try { ( $ __expr : expr ) => { match $ __expr { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } } } # [ automatically_derived ] impl < 'de > _serde :: Deserialize < 'de > for Input { fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { # [ allow ( non_camel_case_types ) ] enum __Field { __field0 , __ignore , } struct __FieldVisitor ; impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "field identifier" ) } fn visit_u64 < __E > ( self , __value : u64 ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { 0u64 => _serde :: export :: Ok ( __Field :: __field0 ) , _ => _serde :: export :: Err ( _serde :: de :: Error :: invalid_value ( _serde :: de :: Unexpected :: Unsigned ( __value ) , & "field index 0 <= i < 1" ) ) , } } fn visit_str < __E > ( self , __value : & str ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { "message" => _serde :: export :: Ok ( __Field :: __field0 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } fn visit_bytes < __E > ( self , __value : & [ u8 ] ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { b"message" => _serde :: export :: Ok ( __Field :: __field0 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } } impl < 'de > _serde :: Deserialize < 'de > for __Field { # [ inline ] fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { _serde :: Deserializer :: deserialize_identifier ( __deserializer , __FieldVisitor ) } } struct __Visitor < 'de > { marker : _serde :: export :: PhantomData < Input > , lifetime : _serde :: export :: PhantomData < & 'de ( ) > , } impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = Input ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "struct Input" ) } # [ inline ] fn visit_seq < __A > ( self , mut __seq : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > { let __field0 = match match _serde :: de :: SeqAccess :: next_element :: < String > ( & mut __seq ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { _serde :: export :: Some ( __value ) => __value , _serde :: export :: None => { return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct Input with 1 element" ) ) ; } } ; _serde :: export :: Ok ( Input { message : __field0 , } ) } # [ inline ] fn visit_map < __A > ( self , mut __map : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > { let mut __field0 : _serde :: export :: Option < String > = _serde :: export :: None ; while let _serde :: export :: Some ( __key ) = match _serde :: de :: MapAccess :: next_key :: < __Field > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { match __key { __Field :: __field0 => { if _serde :: export :: Option :: is_some ( & __field0 ) { return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "message" ) ) ; } __field0 = _serde :: export :: Some ( match _serde :: de :: MapAccess :: next_value :: < String > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ) ; } _ => { let _ = match _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; } } } let __field0 = match __field0 { _serde :: export :: Some ( __field0 ) => __field0 , _serde :: export :: None => match _serde :: private :: de :: missing_field ( "message" ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , } ; _serde :: export :: Ok ( Input { message : __field0 , } ) } } const FIELDS : & 'static [ & 'static str ] = & [ "message" ] ; _serde :: Deserializer :: deserialize_struct ( __deserializer , "Input" , FIELDS , __Visitor { marker : _serde :: export :: PhantomData :: < Input > , lifetime : _serde :: export :: PhantomData , } ) } } } ; # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_SERIALIZE_FOR_Input : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ allow ( unused_macros ) ] macro_rules ! try { ( $ __expr : expr ) => { match $ __expr { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } } } # [ automatically_derived ] impl _serde :: Serialize for Input { fn serialize < __S > ( & self , __serializer : __S ) -> _serde :: export :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer { let mut __serde_state = match _serde :: Serializer :: serialize_struct ( __serializer , "Input" , false as usize + 1 ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; match _serde :: ser :: SerializeStruct :: serialize_field ( & mut __serde_state , "message" , & self . message ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; _serde :: ser :: SerializeStruct :: end ( __serde_state ) } } } ; let Input { message } : Input = serde_json :: from_slice ( & near_bindgen :: env :: input ( ) . expect ( "Expected input since method has arguments." ) ) . expect ( "Failed to deserialize input from JSON." ) ; let mut contract : StatusMessage = near_bindgen :: env :: state_read ( ) . unwrap_or_default ( ) ; contract . set_status ( message ) ; near_bindgen :: env :: state_write ( & contract ) ; } # [ cfg ( target_arch = "wasm32" ) ] # [ no_mangle ] pub extern "C" fn get_status ( ) { near_bindgen :: env :: setup_panic_hook ( ) ; near_bindgen :: env :: set_blockchain_interface ( Box :: new ( near_blockchain :: NearBlockchain { } ) ) ; struct Input { account_id : String , } # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_DESERIALIZE_FOR_Input : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ allow ( unused_macros ) ] macro_rules ! try { ( $ __expr : expr ) => { match $ __expr { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } } } # [ automatically_derived ] impl < 'de > _serde :: Deserialize < 'de > for Input { fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { # [ allow ( non_camel_case_types ) ] enum __Field { __field0 , __ignore , } struct __FieldVisitor ; impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "field identifier" ) } fn visit_u64 < __E > ( self , __value : u64 ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { 0u64 => _serde :: export :: Ok ( __Field :: __field0 ) , _ => _serde :: export :: Err ( _serde :: de :: Error :: invalid_value ( _serde :: de :: Unexpected :: Unsigned ( __value ) , & "field index 0 <= i < 1" ) ) , } } fn visit_str < __E > ( self , __value : & str ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { "account_id" => _serde :: export :: Ok ( __Field :: __field0 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } fn visit_bytes < __E > ( self , __value : & [ u8 ] ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { b"account_id" => _serde :: export :: Ok ( __Field :: __field0 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } } impl < 'de > _serde :: Deserialize < 'de > for __Field { # [ inline ] fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { _serde :: Deserializer :: deserialize_identifier ( __deserializer , __FieldVisitor ) } } struct __Visitor < 'de > { marker : _serde :: export :: PhantomData < Input > , lifetime : _serde :: export :: PhantomData < & 'de ( ) > , } impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = Input ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "struct Input" ) } # [ inline ] fn visit_seq < __A > ( self , mut __seq : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > { let __field0 = match match _serde :: de :: SeqAccess :: next_element :: < String > ( & mut __seq ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { _serde :: export :: Some ( __value ) => __value , _serde :: export :: None => { return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct Input with 1 element" ) ) ; } } ; _serde :: export :: Ok ( Input { account_id : __field0 , } ) } # [ inline ] fn visit_map < __A > ( self , mut __map : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > { let mut __field0 : _serde :: export :: Option < String > = _serde :: export :: None ; while let _serde :: export :: Some ( __key ) = match _serde :: de :: MapAccess :: next_key :: < __Field > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { match __key { __Field :: __field0 => { if _serde :: export :: Option :: is_some ( & __field0 ) { return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "account_id" ) ) ; } __field0 = _serde :: export :: Some ( match _serde :: de :: MapAccess :: next_value :: < String > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ) ; } _ => { let _ = match _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; } } } let __field0 = match __field0 { _serde :: export :: Some ( __field0 ) => __field0 , _serde :: export :: None => match _serde :: private :: de :: missing_field ( "account_id" ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , } ; _serde :: export :: Ok ( Input { account_id : __field0 , } ) } } const FIELDS : & 'static [ & 'static str ] = & [ "account_id" ] ; _serde :: Deserializer :: deserialize_struct ( __deserializer , "Input" , FIELDS , __Visitor { marker : _serde :: export :: PhantomData :: < Input > , lifetime : _serde :: export :: PhantomData , } ) } } } ; # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_SERIALIZE_FOR_Input : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ allow ( unused_macros ) ] macro_rules ! try { ( $ __expr : expr ) => { match $ __expr { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } } } # [ automatically_derived ] impl _serde :: Serialize for Input { fn serialize < __S > ( & self , __serializer : __S ) -> _serde :: export :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer { let mut __serde_state = match _serde :: Serializer :: serialize_struct ( __serializer , "Input" , false as usize + 1 ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; match _serde :: ser :: SerializeStruct :: serialize_field ( & mut __serde_state , "account_id" , & self . account_id ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; _serde :: ser :: SerializeStruct :: end ( __serde_state ) } } } ; let Input { account_id } : Input = serde_json :: from_slice ( & near_bindgen :: env :: input ( ) . expect ( "Expected input since method has arguments." ) ) . expect ( "Failed to deserialize input from JSON." ) ; let contract : StatusMessage = near_bindgen :: env :: state_read ( ) . unwrap_or_default ( ) ; let result = contract . get_status ( account_id ) ; let result = serde_json :: to_vec ( & result ) . expect ( "Failed to serialize the return value using JSON." ) ; near_bindgen :: env :: value_return ( & result ) ; } # [ cfg ( target_arch = "wasm32" ) ] # [ no_mangle ] pub extern "C" fn metadata ( ) { use borsh :: * ; let metadata = near_bindgen :: Metadata :: new ( < [ _ ] > :: into_vec ( box [ near_bindgen :: MethodMetadata { name : "set_status" . to_string ( ) , is_view : false , is_init : false , args : { struct Input { message : String , } impl borsh :: BorshSchema for Input where String : borsh :: BorshSchema { fn declaration ( ) -> borsh :: schema :: Declaration { "Input" . to_string ( ) } fn add_definitions_recursively ( definitions : & mut :: std :: collections :: HashMap < borsh :: schema :: Declaration , borsh :: schema :: Definition > ) { let fields = borsh :: schema :: Fields :: NamedFields ( < [ _ ] > :: into_vec ( box [ ( "message" . to_string ( ) , < String > :: declaration ( ) ) ] ) ) ; let definition = borsh :: schema :: Definition :: Struct { fields , } ; Self :: add_definition ( Self :: declaration ( ) , definition , definitions ) ; < String > :: add_definitions_recursively ( definitions ) ; } } # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_DESERIALIZE_FOR_Input : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ allow ( unused_macros ) ] macro_rules ! try { ( $ __expr : expr ) => { match $ __expr { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } } } # [ automatically_derived ] impl < 'de > _serde :: Deserialize < 'de > for Input { fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { # [ allow ( non_camel_case_types ) ] enum __Field { __field0 , __ignore , } struct __FieldVisitor ; impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "field identifier" ) } fn visit_u64 < __E > ( self , __value : u64 ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { 0u64 => _serde :: export :: Ok ( __Field :: __field0 ) , _ => _serde :: export :: Err ( _serde :: de :: Error :: invalid_value ( _serde :: de :: Unexpected :: Unsigned ( __value ) , & "field index 0 <= i < 1" ) ) , } } fn visit_str < __E > ( self , __value : & str ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { "message" => _serde :: export :: Ok ( __Field :: __field0 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } fn visit_bytes < __E > ( self , __value : & [ u8 ] ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { b"message" => _serde :: export :: Ok ( __Field :: __field0 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } } impl < 'de > _serde :: Deserialize < 'de > for __Field { # [ inline ] fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { _serde :: Deserializer :: deserialize_identifier ( __deserializer , __FieldVisitor ) } } struct __Visitor < 'de > { marker : _serde :: export :: PhantomData < Input > , lifetime : _serde :: export :: PhantomData < & 'de ( ) > , } impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = Input ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "struct Input" ) } # [ inline ] fn visit_seq < __A > ( self , mut __seq : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > { let __field0 = match match _serde :: de :: SeqAccess :: next_element :: < String > ( & mut __seq ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { _serde :: export :: Some ( __value ) => __value , _serde :: export :: None => { return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct Input with 1 element" ) ) ; } } ; _serde :: export :: Ok ( Input { message : __field0 , } ) } # [ inline ] fn visit_map < __A > ( self , mut __map : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > { let mut __field0 : _serde :: export :: Option < String > = _serde :: export :: None ; while let _serde :: export :: Some ( __key ) = match _serde :: de :: MapAccess :: next_key :: < __Field > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { match __key { __Field :: __field0 => { if _serde :: export :: Option :: is_some ( & __field0 ) { return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "message" ) ) ; } __field0 = _serde :: export :: Some ( match _serde :: de :: MapAccess :: next_value :: < String > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ) ; } _ => { let _ = match _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; } } } let __field0 = match __field0 { _serde :: export :: Some ( __field0 ) => __field0 , _serde :: export :: None => match _serde :: private :: de :: missing_field ( "message" ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , } ; _serde :: export :: Ok ( Input { message : __field0 , } ) } } const FIELDS : & 'static [ & 'static str ] = & [ "message" ] ; _serde :: Deserializer :: deserialize_struct ( __deserializer , "Input" , FIELDS , __Visitor { marker : _serde :: export :: PhantomData :: < Input > , lifetime : _serde :: export :: PhantomData , } ) } } } ; # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_SERIALIZE_FOR_Input : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ allow ( unused_macros ) ] macro_rules ! try { ( $ __expr : expr ) => { match $ __expr { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } } } # [ automatically_derived ] impl _serde :: Serialize for Input { fn serialize < __S > ( & self , __serializer : __S ) -> _serde :: export :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer { let mut __serde_state = match _serde :: Serializer :: serialize_struct ( __serializer , "Input" , false as usize + 1 ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; match _serde :: ser :: SerializeStruct :: serialize_field ( & mut __serde_state , "message" , & self . message ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; _serde :: ser :: SerializeStruct :: end ( __serde_state ) } } } ; Some ( Input :: schema_container ( ) ) } , callbacks : < [ _ ] > :: into_vec ( box [ ] ) , callbacks_vec : None , result : None , } , near_bindgen :: MethodMetadata { name : "get_status" . to_string ( ) , is_view : true , is_init : false , args : { struct Input { account_id : String , } impl borsh :: BorshSchema for Input where String : borsh :: BorshSchema { fn declaration ( ) -> borsh :: schema :: Declaration { "Input" . to_string ( ) } fn add_definitions_recursively ( definitions : & mut :: std :: collections :: HashMap < borsh :: schema :: Declaration , borsh :: schema :: Definition > ) { let fields = borsh :: schema :: Fields :: NamedFields ( < [ _ ] > :: into_vec ( box [ ( "account_id" . to_string ( ) , < String > :: declaration ( ) ) ] ) ) ; let definition = borsh :: schema :: Definition :: Struct { fields , } ; Self :: add_definition ( Self :: declaration ( ) , definition , definitions ) ; < String > :: add_definitions_recursively ( definitions ) ; } } # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_DESERIALIZE_FOR_Input : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ allow ( unused_macros ) ] macro_rules ! try { ( $ __expr : expr ) => { match $ __expr { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } } } # [ automatically_derived ] impl < 'de > _serde :: Deserialize < 'de > for Input { fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { # [ allow ( non_camel_case_types ) ] enum __Field { __field0 , __ignore , } struct __FieldVisitor ; impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "field identifier" ) } fn visit_u64 < __E > ( self , __value : u64 ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { 0u64 => _serde :: export :: Ok ( __Field :: __field0 ) , _ => _serde :: export :: Err ( _serde :: de :: Error :: invalid_value ( _serde :: de :: Unexpected :: Unsigned ( __value ) , & "field index 0 <= i < 1" ) ) , } } fn visit_str < __E > ( self , __value : & str ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { "account_id" => _serde :: export :: Ok ( __Field :: __field0 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } fn visit_bytes < __E > ( self , __value : & [ u8 ] ) -> _serde :: export :: Result < Self :: Value , __E > where __E : _serde :: de :: Error { match __value { b"account_id" => _serde :: export :: Ok ( __Field :: __field0 ) , _ => { _serde :: export :: Ok ( __Field :: __ignore ) } } } } impl < 'de > _serde :: Deserialize < 'de > for __Field { # [ inline ] fn deserialize < __D > ( __deserializer : __D ) -> _serde :: export :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > { _serde :: Deserializer :: deserialize_identifier ( __deserializer , __FieldVisitor ) } } struct __Visitor < 'de > { marker : _serde :: export :: PhantomData < Input > , lifetime : _serde :: export :: PhantomData < & 'de ( ) > , } impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = Input ; fn expecting ( & self , __formatter : & mut _serde :: export :: Formatter ) -> _serde :: export :: fmt :: Result { _serde :: export :: Formatter :: write_str ( __formatter , "struct Input" ) } # [ inline ] fn visit_seq < __A > ( self , mut __seq : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > { let __field0 = match match _serde :: de :: SeqAccess :: next_element :: < String > ( & mut __seq ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { _serde :: export :: Some ( __value ) => __value , _serde :: export :: None => { return _serde :: export :: Err ( _serde :: de :: Error :: invalid_length ( 0usize , & "struct Input with 1 element" ) ) ; } } ; _serde :: export :: Ok ( Input { account_id : __field0 , } ) } # [ inline ] fn visit_map < __A > ( self , mut __map : __A ) -> _serde :: export :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > { let mut __field0 : _serde :: export :: Option < String > = _serde :: export :: None ; while let _serde :: export :: Some ( __key ) = match _serde :: de :: MapAccess :: next_key :: < __Field > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } { match __key { __Field :: __field0 => { if _serde :: export :: Option :: is_some ( & __field0 ) { return _serde :: export :: Err ( < __A :: Error as _serde :: de :: Error > :: duplicate_field ( "account_id" ) ) ; } __field0 = _serde :: export :: Some ( match _serde :: de :: MapAccess :: next_value :: < String > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ) ; } _ => { let _ = match _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny > ( & mut __map ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; } } } let __field0 = match __field0 { _serde :: export :: Some ( __field0 ) => __field0 , _serde :: export :: None => match _serde :: private :: de :: missing_field ( "account_id" ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } , } ; _serde :: export :: Ok ( Input { account_id : __field0 , } ) } } const FIELDS : & 'static [ & 'static str ] = & [ "account_id" ] ; _serde :: Deserializer :: deserialize_struct ( __deserializer , "Input" , FIELDS , __Visitor { marker : _serde :: export :: PhantomData :: < Input > , lifetime : _serde :: export :: PhantomData , } ) } } } ; # [ allow ( non_upper_case_globals , unused_attributes , unused_qualifications ) ] const _IMPL_SERIALIZE_FOR_Input : ( ) = { # [ allow ( unknown_lints ) ] # [ allow ( rust_2018_idioms ) ] extern crate serde as _serde ; # [ allow ( unused_macros ) ] macro_rules ! try { ( $ __expr : expr ) => { match $ __expr { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } } } # [ automatically_derived ] impl _serde :: Serialize for Input { fn serialize < __S > ( & self , __serializer : __S ) -> _serde :: export :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer { let mut __serde_state = match _serde :: Serializer :: serialize_struct ( __serializer , "Input" , false as usize + 1 ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; match _serde :: ser :: SerializeStruct :: serialize_field ( & mut __serde_state , "account_id" , & self . account_id ) { _serde :: export :: Ok ( __val ) => __val , _serde :: export :: Err ( __err ) => { return _serde :: export :: Err ( __err ) ; } } ; _serde :: ser :: SerializeStruct :: end ( __serde_state ) } } } ; Some ( Input :: schema_container ( ) ) } , callbacks : < [ _ ] > :: into_vec ( box [ ] ) , callbacks_vec : None , result : Some ( Option :: < String > :: schema_container ( ) ) , } ] ) ) ; let data = borsh :: try_to_vec_with_schema ( & metadata ) . expect ( "Failed to serialize the metadata using Borsh" ) ; near_bindgen :: env :: value_return ( & data ) ; }